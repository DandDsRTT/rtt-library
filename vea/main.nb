(* MULTIVECTOR UTILITIES *)

(*

veaGetD[multivector]

Given a representation of a temperament as a multivector,
returns the dimensionality.

Examples:

In    meantoneMultimap = {{1, 4, 4}, "co", 2, 3};
      veaGetD[meantoneMultimap]

Out   3

In    meantoneMulticomma = {{4, -4, 1}, "contra", 1, 3};
      veaGetD[meantoneMulticomma]

Out   3

*)
veaGetD[w_] := If[
  isInvalid[w],
  Error, (* TODO: invalidity wrapper? *)
  validVeaDimensionality[w]
];

(*

veaGetR[multivector]

Given a representation of a temperament as a multivector,
returns the rank.

Examples:

In    meantoneMultimap = {{1, 4, 4}, "co", 2, 3};
      veaGetR[meantoneMultimap]

Out   2

In    meantoneMulticomma = {{4, -4, 1}, "contra", 1, 3};
      veaGetR[meantoneMulticomma]

Out   2

*)
veaGetR[w_] := If[
  isInvalid[w],
  Error,
  validVeaRank[w]
];

(*

veaGetN[multivector]

Given a representation of a temperament as a multivector,
returns the nullity.

Examples:

In    meantoneMultimap = {{1, 4, 4}, "co", 2, 3};
      veaGetN[meantoneMultimap]

Out   1

In    meantoneMulticomma = {{4, -4, 1}, "contra", 1, 3};
      veaGetN[meantoneMulticomma]

Out   1

*)
veaGetN[w_] := If[
  isInvalid[w],
  Error,
  validVeaNullity[w]
];


(* MULTIVECTOR FORMS & DEFACTORING *)

(*

veaCanonicalForm[multivector]

Returns the given multivector in canonical form.

If a multimap, the GCD is extracted,
and the leading entry is normalized to positive.
If a multicomma, the GCD is extracted,
and the trailing entry is normalized to positive.

Examples:

In    enfactoredMeantoneMultimap = {{2, 8, 8}, "co", 2, 3};
      veaCanonicalForm[enfactoredMeantoneMultimap]

Out   {{1, 4, 4}, "co", 2, 3}

In    wrongSignMeantoneMulticomma = {{-4, 4, -1}, "contra", 1, 3};
      veaCanonicalForm[wrongSignMeantoneMulticomma]

Out   {{4, -4, 1}, "contra", 1, 3}

*)
veaCanonicalForm[w_] := If[
  isInvalid[w],
  Error,
  validVeaCanonicalForm[w]
];


(* DUAL *)

(*

veaDual[multivector]

Given a multivector, returns its dual in canonical form.

Examples:

In    meantoneMultimap = {{1, 4, 4}, "co", 2, 3};
      veaDual[meantoneMultimap]

Out   {{4, -4, 1}, "contra", 1, 3}

In    nilovector = {{1}, "contra", 0, 3};
      d = 3
      veaDual[nilovector, d]

Out   {{1}, "co", 0, 3}

*)
veaDual[w_] := If[
  isInvalid[w],
  Error,
  validVeaDual[w]
];


(* CONVERSION TO AND FROM MATRIX *)

(*

multivectorToMatrix[multivector]

Given a temperament represented as a multivector,
returns the corresponding mapping or comma-basis
(given a multimap, returns the corresponding mapping, or
given a multicomma, returns the corresponding comma-basis).
The matrix is returned in canonical form.

In    meantoneMultimap = {{1, 4, 4}, "co", 2, 3};
      multivectorToMatrix[meantoneMultimap]

Out   {{{1, 0, -4}, {0, 1, 4}}, "mapping"}

*)
multivectorToMatrix[w_] := Module[{grade, t},
  grade = getGrade[w];
  t = If[
    grade == 0,
    nilovectorToMatrix[w],
    If[
      grade == 1,
      monovectorToMatrix[w],
      If[
        veaIsContra[w],
        contravariantMultivectorToCommaBasis[w],
        covariantMultivectorToMapping[w]
      ]
    ]
  ];

  If[t === Error, Error, canonicalForm[t]]
];

(*

matrixToMultivector[mapping]

Given a temperament represented as a mapping or comma-basis,
returns the corresponding multivector
(for a mapping, returns a multimap, or
for a comma-basis, returns a multicomma).
The multivector is returned in canonical form.

In    meantoneMapping = {{{1, 0, -4}, {0, 1, 4}}, "mapping"};
      matrixToMultivector[meantoneMapping]

Out   {{1, 4, 4}, "co", 2, 3}

*)
matrixToMultivector[t_] := veaCanonicalForm[
  If[
    isContra[t],
    {minorsList[getA[t]], getV[t], getN[t], getD[t]},
    {minorsList[getA[t]], getV[t], getR[t], getD[t]}
  ]
];


(* MEET AND JOIN *)



(* ___ PRIVATE ___ *)



(* MULTIVECTOR UTILITIES *)

veaIsContra[w_] := MemberQ[{
  "contra",
  "contravector",
  "multicontravector",
  "contravariant",
  "v",
  "vector",
  "c",
  "comma",
  "multicomma",
  "i",
  "interval",
  "multinterval",
  "multiinterval",
  "monzo",
  "multimonzo",
  "against"
}, veaGetV[w]];
veaIsCo[w_] := MemberQ[{
  "co",
  "covector",
  "multicovector",
  "covariant",
  "m",
  "map",
  "multimap",
  "val",
  "multival",
  "with",
  "wedgie"
}, veaGetV[w]];

validVeaDimensionality[{minors_, v_, grade_, d_}] := d;
validVeaRank[w_] := If[
  veaIsCo[w],
  getGrade[w],
  validVeaDimensionality[w] - validVeaNullity[w]
];
validVeaNullity[w_] := If[
  veaIsContra[w],
  getGrade[w],
  validVeaDimensionality[w] - validVeaRank[w]
];

veaIndices[d_, grade_] := Subsets[Range[d], {grade}];

isInvalid[v_] := multivectorToMatrix[v] === Error;

getMinors[{minors_, v_, grade_, d_}] := minors;
veaGetV[{minors_, v_, grade_, d_}] := v;
getGrade[{minors_, v_, grade_, d_}] := grade;


(* MULTIVECTOR FORMS & DEFACTORING *)


validVeaCanonicalForm[{minors_, v_, grade_, d_}] := Module[{defactoredMinors},
  defactoredMinors = extractGcd[minors];

  If[
    veaIsCo[{minors, v, grade, d}],
    If[
      leadingEntry[minors] < 0,
      {-1 * defactoredMinors, v, grade, d},
      {defactoredMinors, v, grade, d}
    ],
    If[
      trailingEntry[minors] < 0,
      {-1 * defactoredMinors, v, grade, d},
      {defactoredMinors, v, grade, d}
    ]
  ]
];


(* DUAL *)

getDualV[w_] := If[
  veaIsCo[w],
  "contra",
  "co"
];

validVeaDual[w_] := Module[{dualV, d, grade},
  dualV = getDualV[w];
  d = validVeaDimensionality[w];
  grade = getGrade[w];

  If[
    grade == 0,
    {{1}, dualV, d, d},
    If[
      grade == d,
      {{1}, dualV, 0, d},
      Module[{dualGrade, tensor, dualTensor, dualW},
        dualGrade = d - grade;
        tensor = multivectorToTensor[w];
        dualTensor = HodgeDual[tensor];
        dualW = tensorToMultivector[dualTensor, dualV, dualGrade, d];

        validVeaCanonicalForm[dualW]
      ]
    ]
  ]
];

multivectorToTensor[{minors_, v_, grade_, d_}] := SymmetrizedArray[
  MapThread[Rule[#1, #2]&, {veaIndices[d, grade], minors}],
  ConstantArray[d, grade],
  Antisymmetric[All]
];

tensorToMultivector[tensor_, v_, grade_, d_] := Module[{assoc, signTweak},
  assoc = Association[SymmetrizedArrayRules[tensor]];
  signTweak = If[veaIsCo[{{}, v, grade, d}] && Mod[grade(d - grade), 2] == 1, -1, 1];
  minors = signTweak * Map[If[KeyExistsQ[assoc, #], assoc[#], 0]&, veaIndices[d, grade]];

  {minors, v, grade, d}
];


(* CONVERSION TO AND FROM MATRIX *)

nilovectorToMatrix[{minors_, v_, grade_, d_}] := {{Table[0, d]}, v};

monovectorToMatrix[{minors_, v_, grade_, d_}] := {{minors}, v};

covariantMultivectorToMapping[w_] := Module[{grade, flattenedTensorMatrix},
  grade = getGrade[w];
  flattenedTensorMatrix = hnf[Flatten[multivectorToTensor[w], grade - 2]];

  If[
    MatrixRank[flattenedTensorMatrix] != grade,
    Error,
    {Take[flattenedTensorMatrix, grade], veaGetV[w]}
  ]
];

contravariantMultivectorToCommaBasis[w_] := Module[{grade, flattenedTensorMatrix},
  grade = getGrade[w];
  flattenedTensorMatrix = hnf[reverseEachRow[Flatten[multivectorToTensor[w], grade - 2]]];

  If[
    MatrixRank[flattenedTensorMatrix] != grade,
    Error,
    {antiTranspose[Take[flattenedTensorMatrix, grade]], veaGetV[w]}
  ]
];

minorsList[a_] := extractGcd[First[Minors[a, MatrixRank[a]]]];


(* MEET AND JOIN *)

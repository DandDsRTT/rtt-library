smithVectoralToMatrix[{w_, s_}] := If[
  s < 0,
  smithMultimapToMapping[{w, s}],
  dual[smithMultimapToMapping[veaDual[{w, s}]]]
]

smithMultimapToMapping[{w_, s_}] := Module[{r, d, c, b, indexedW},
  r = -s;
  d = veaDimensionality[{w, s}];

  c = veaIndices[d, r - 1];
  b = veaIndices[d, r];

  indexedW = Association[];
  MapThread[(indexedW[#1] = #2)&, {b, w}];

  fit[hnf[Map[findRowForElOfC[#, indexedW]&, c]]]
];

findRowForElOfC[cEl_, indexedW_] := Module[{appendedUnsortedIndices, signsAndSortedIndices, signs, sortedIndices, minors},
  appendedUnsortedIndices = Map[Join[cEl, {#}]&, Range[Length[indexedW]]];

  signsAndSortedIndices = Map[findSignsAndSortedIndices, appendedUnsortedIndices];
  signs = Map[First, signsAndSortedIndices];
  sortedIndices = Map[Last, signsAndSortedIndices];

  minors = Map[indexedW[#]&, sortedIndices];

  MapThread[Times, {minors, signs}]
];

findSignsAndSortedIndices[unsortedIndices_] := Module[{sortedIndicesAndSwapCount, sortedIndices, swapCount},
  sortedIndicesAndSwapCount = sortIndicesAndCountSwaps[unsortedIndices];
  sortedIndices = First[sortedIndicesAndSwapCount];
  swapCount = Last[sortedIndicesAndSwapCount];

  If[
    DuplicateFreeQ[unsortedIndices],
    If[
      EvenQ[swapCount],
      {1, sortedIndices},
      {-1, sortedIndices}
    ],
    {0, sortedIndices}
  ]
];

sortIndicesAndCountSwaps[inputUnsortedIndices_] := Module[{swapCount, indices},
  swapCount = 0;
  indices = inputUnsortedIndices;

  While[
    indices != Sort[indices],
    For[i = 1, i < Length[indices], i++,
      el = indices[[i]];
      nextEl = indices[[i + 1]];
      If[el > nextEl,
        indices[[i]] = nextEl;
        indices[[i + 1]] = el;
        swapCount = swapCount + 1
      ]
    ]
  ];

  {indices, swapCount}
];


smithVectoralToMatrix[{{1, 2, -2, -5}, -3}]
smithVectoralToMatrix[{{1, 4, 4}, -2}]
smithVectoralToMatrix[{{4, -4, 1}, 1}]

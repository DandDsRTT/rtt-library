(* VECTORAL UTILITIES *)

(*

veaDimensionality[vectoral]

Given a vectoral, returns the dimensionality of the system.

In the case of a zero-grade vectoral, this function will error,
because there is no way to tell in that case.

Examples:

In    meantoneMultimap = {{1, 4, 4}, -2};
      veaDimensionality[meantoneMultimap]

Out   3

In    meantoneMulticomma = {{4, -4, 1}, 1};
      veaDimensionality[meantoneMulticomma]

Out   3

*)
veaDimensionality[{w_, s_}] := If[
  s == 0,
  Error,
  Module[{d},
    First[Association[Solve[
      Binomial[d, Abs[s]] == Length[w] && d >= 0,
      d,
      Integers
    ]]]
  ]
];

(*

veaRank[vectoral]

Given a vectoral, returns the rank of the system.

In the case of a zero-grade vectoral, this function will error,
because there is no way to tell in that case.

Examples:

In    meantoneMultimap = {{1, 4, 4}, -2};
      veaRank[meantoneMultimap]

Out   2

In    meantoneMulticomma = {{4, -4, 1}, 1};
      veaRank[meantoneMulticomma]

Out   2

*)
veaRank[{w_, s_}] := If[
  s == 0,
  Error,
  If[s < 0, -s, veaDimensionality[{w, s}] - veaNullity[{w, s}]]
];

(*

veaNullity[vectoral]

Given a vectoral, returns the nullity of the system.

In the case of a zero-grade vectoral, this function will error,
because there is no way to tell in that case.

Examples:

In    meantoneMultimap = {{1, 4, 4}, -2};
      veaNullity[meantoneMultimap]

Out   1

In    meantoneMulticomma = {{4, -4, 1}, 1};
      veaNullity[meantoneMulticomma]

Out   1

*)
veaNullity[{w_, s_}] := If[
  s == 0,
  Error,
  If[s > 0, s, veaDimensionality[{w, s}] - veaRank[{w, s}]]
];


(* VECTORAL FORMS & DEFACTORING *)

(*

veaCanonicalForm[vectoral]

Returns the given vectoral in canonical form
(GCD extracted, and multimap normalized to positive pivot).

*)
veaCanonicalForm[{w_, s_}] := If[
  s < 0 && pivot[w] < 0,
  {-1 * extractGcd[w], s},
  {extractGcd[w], s}
];


(* DUAL *)

(*

veaDual[vectoral(, signedGradeOfDual)]

Given a vectoral, returns its dual in canonical form.

In the case of a zero-grade vectoral, it is necessary to supply
the variance-signed grade of the dual as a second argument.
Otherwise, there would be no way to tell either the dimensionality of the system,
or which of the input or output was the multimap and which was the multicomma.

*)
veaDual[{w_, s_}, inputDualS_ : Null] := Module[{d, g, signG, dualG, dualS, signTweak},
  g = Abs[s];
  signG = Sign[s];
  d = veaDimensionality[{w, s}];
  dualG = d - g;
  dualS = If[s == 0, inputDualS, -signG * dualG];

  If[
    s == 0,
    {{1}, dualS},
    If[
      g == d,
      {{1}, 0},
      veaCanonicalForm[tensorToVectoral[HodgeDual[ vectoralToTensor[{w, s}]], d, dualS]]
    ]
  ]
];


(* CONVERSION TO AND FROM MATRIX *)

(*

vectoralToMatrix[vectoral]

Given a vectoral, returns the corresponding matrix
(given a multimap, returns the corresponding mapping, or
given a multicomma, returns the corresponding comma-basis).
The matrix is returned in canonical form.

*)
vectoralToMatrix[{inputW_, s_}] := Module[{w, g},
  w = extractGcd[inputW];
  g = Abs[s];

  If[
    s == 0,
    {},
    If[
      s == 1,
      Transpose[{w}],
      If[
        s == -1,
        {w},
        If[
          s > 1,
          antiTranspose[Take[hnf[reverseRows[vectoralToFlattenedTensorMatrix[{w, s}]]], g]],
          Take[hnf[vectoralToFlattenedTensorMatrix[{w, s}]], g]
        ]
      ]
    ]
  ]
];

(*

matrixToVectoral[mapping(, signedGrade)]

Given a matrix, returns the corresponding vectoral
(given a mapping, returns the corresponding multimap, or
given a comma-basis, returns the corresponding multicomma).
The vectoral is returned in canonical form.

In the case where the matrix cannot be identified as either
a mapping or a comma-basis (it is square after rank/nullity
deficiencies have been removed), it is necessary to supply
the variance-signed grade of the desired vectoral.

*)
matrixToVectoral[a_, s_ : Null] := If[
  a == {},
  {{1}, 0},
  Module[{fitA},
    fitA = fit[a];

    If[
      isSquare[fitA],
      {minorsList[fitA], s},
      If[
        isCommaBasis[fitA],
        {minorsList[Transpose[fitA]], nullity[fitA]},
        {minorsList[fitA], -rank[fitA]}
      ]
    ]
  ]
];


(* MEET AND JOIN *)
